import datetime
import collections

snake =  [(160, 440), (140, 440), (120, 440), (100, 440), (80, 440), (60, 440), (40, 440), (20, 440), (20, 420), (40, 420), (60, 420), (80, 420), (100, 420), (120, 420), (140, 420), (160, 
420), (180, 420), (200, 420), (220, 420), (240, 420), (260, 420), (280, 420), (300, 420), (320, 420), (340, 420), (360, 420), (380, 420)]

food = (60,80)


GRID =[]

SCREEN_WIDTH = 480
SCREEN_HEIGHT = 480

GRIDSIZE = 20
GRID_WIDTH = SCREEN_WIDTH / GRIDSIZE
GRID_HEIGHT = SCREEN_HEIGHT / GRIDSIZE


GridLocation = (0,0)

class SquareGrid:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.walls = []
    
    def in_bounds(self, id: GridLocation) -> bool:
        (x, y) = id
        return 0 <= x < self.width and 0 <= y < self.height
    
    def passable(self, GridLocation) -> bool:
        return GridLocation not in self.walls
    
    def neighbors(self, GridLocation):
        (x, y) = GridLocation
        neighbors = [(x+1, y), (x-1, y), (x, y-1), (x, y+1)] # E W N S
        # see "Ugly paths" section for an explanation:
        if (x + y) % 2 == 0: neighbors.reverse() # S N W E
        results = filter(self.in_bounds, neighbors)
        results = filter(self.passable, results)
        return results


class Queue:
    def __init__(self):
        self.elements = collections.deque()
    
    def empty(self) -> bool:
        return not self.elements
    
    def put(self, x):
        self.elements.append(x)
    
    def get(self):
        return self.elements.popleft()


def generateGridCoordinates(): #generates all coordinate points on the grid board, this is used to generate the starting point. 
    for i in range(int(GRID_WIDTH)):
        for j in range(int(GRID_HEIGHT)):
            GRID.append((i*GRIDSIZE,j*GRIDSIZE))

def breadth_first_search(graph, start):
    frontier = Queue()
    frontier.put(start)
    came_from: Dict[Location, Optional[Location]] = {}
    came_from[start] = None
    
    while not frontier.empty():
        current: Location = frontier.get()
        for next in graph.neighbors(current):
            if next not in came_from:
                frontier.put(next)
                came_from[next] = current
    
    return came_from


def bfs():
    begin_time = datetime.datetime.now()

    tmp_grid = [[0 for y in range(int(GRID_HEIGHT))] for x in range(int(GRID_WIDTH))]

    for elm in snake:
        x, y = int(elm[0]/GRIDSIZE), int(elm[1]/GRIDSIZE)
        tmp_grid[x][y]=1
    tmp_grid[int(snake[0][0]/GRIDSIZE)][int(snake[0][1]/GRIDSIZE)] = 2
    tmp_grid[int(food[0]/GRIDSIZE)][int(food[1]/GRIDSIZE)] = 5

    for i in tmp_grid:
        print(i)

    g = SquareGrid(30, 15)
    g.walls = DIAGRAM1_WALLS

    start = (8, 7)
    parents = breadth_first_search(g, start)
    draw_grid(g, point_to=parents, start=start)

    breadth_first_search(g, start)


    print('Time to complete: ' + str(datetime.datetime.now() - begin_time))


bfs()


